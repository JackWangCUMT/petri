/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef lock_h
#define lock_h

using lockIterator_t = std::vector<std::unique_lock<std::mutex>>::iterator;

namespace {

    /*
     * The following code is coming from the Boost version 1.58's "lock_algorithms.hpp" header file,
     * and comes along the following copyright notices:
     * (C) Copyright 2007 Anthony Williams
     * (C) Copyright 2011-2012 Vicente J. Botet Escriba
     *
     * It has been modified to fit the project's needs, according to the Boost Software License
     * Version 1.0's terms, quoted at the beginning of this file.
     */

    void lock(lockIterator_t begin, lockIterator_t end);

    struct range_lock_guard {
        lockIterator_t begin;
        lockIterator_t end;

        range_lock_guard(lockIterator_t begin_, lockIterator_t end_)
                : begin(begin_)
                , end(end_) {
            lock(begin, end);
        }

        void release() {
            begin = end;
        }

        ~range_lock_guard() {
            for(; begin != end; ++begin) {
                begin->unlock();
            }
        }
    };

    lockIterator_t try_lock(lockIterator_t begin, lockIterator_t end) {
        if(begin == end) {
            return end;
        }

        auto &guard = *begin;
        guard.try_lock();

        if(!guard.owns_lock()) {
            return begin;
        }
        lockIterator_t const failed = try_lock(++begin, end);
        if(failed == end) {
            guard.release();
        }

        return failed;
    }

    void lock(lockIterator_t begin, lockIterator_t end) {
        if(begin == end) {
            return;
        }

        bool start_with_begin = true;
        lockIterator_t second = begin;
        ++second;
        lockIterator_t next = second;

        for(;;) {
            auto &begin_lock = *begin;
            if(start_with_begin) {
                begin_lock.lock();
                lockIterator_t const failed_lock = try_lock(next, end);
                if(failed_lock == end) {
                    begin_lock.release();
                    return;
                }
                start_with_begin = false;
                next = failed_lock;
            } else {
                range_lock_guard guard(next, end);
                if(begin_lock.try_lock()) {
                    lockIterator_t const failed_lock = try_lock(second, next);
                    if(failed_lock == next) {
                        begin_lock.release();
                        guard.release();
                        return;
                    }
                    start_with_begin = false;
                    next = failed_lock;
                } else {
                    start_with_begin = true;
                    next = second;
                }
            }
        }
    }
}


#endif /* lock_h */
